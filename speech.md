-- 

Программа должна работать (Ну как же без этого!) И еще она должна работать быстро.

Производительность программного обеспечения (ПО) является важным аспектом в разработке любого программного продукта. Актуальность вопроса объясняется постоянно возрастающей сложностью и значимостью программных средств (под значимостью я понимаю рост количества пользователей ПО).

Как нельзя ожидать, что программа будет работать без ошибок с самого первого запуска, так нельзя ожидать того, что программа просто так начнет показывать высокую производительность. 
В соответствии с принципом Парето, только 20% программного кода будет оказывать существенное влияние на производительность приложения вцелом. Эти 20% процентов зачастую называются bottleneck, бутылочным горлышком, или же просто узким местом.

--

Для того, чтобы выявить узкое место в приложении нужны две вещи:
1) Требования к производительности. Причем требования должны быть соствлены еще на этапе проектирования программного обеспечения.
2) Сведения о работе приложения, иначе такие сведения называют значениями характеристик производительности. Такие значения можно получать из различных источников. Можно анализировать отчеты счетчиков производительности. Можно запускать профилировщики и искать проблемы. А можно просто собирать информацию о работе приложения под нагрузкой.

--

Требования дожны быть сформулированы на этапе проектирования приложения и уточнены далее на этапе разработки и поддержки.
Требования к производительности во многом зависят от назначения приложения и его архитектуры. Было бы глупо требовать от приложений таких как Web-база объема используемой оперативной памяти сравнимых с объемом, требуемых для мобильных приложений.

Рассмотрим примеры плохо сформулированных требований:
* Высокая отзывчивость при одновременном доступе нескольких пользователей.
* Низкий объем потребления памяти при небольшом количестве посетителей.

В данном случае не говорится о конкретных характеристиках и не оговариваются ограничения системы, при которых указываемые характеристики должны удовлетворять требованиям.

|               |                                                        |              |
|---------------|--------------------------------------------------------|--------------|
| Веб-сервер    | Время на обработку запроса не более 300 мс             | Одновременно не более 300 запросов в секунду
| Веб-сервер    | Объем используемой оперативной памяти не более 20 Гб   | Одновременно открыто не более 5000 сеансов пользователей
| Клиентское ПО | Время открытия приложения не должно превышать 1500 мс  | 8 Гб оперативной памяти
| Клиентское ПО | Нагрузка на ЦП в режиме простоя не должна превышать 1% | Процессор Intel Core i7 4790 3,6 ГГц или AMD FX-9590 4,7 ГГц 

--

Формулировка требований к производительности напряму зависит от того, какие характеристики производительности мы будем учитывать. В отличие от требований, характеристики не привязаны к каким-то конкретным типам приложений.

                     |       
---------------------|--------------------------------------------------
Нагрузка на CPU      | %
Использование памяти | Килобайты, мегабайты, гигабайты
Время выполнения     | Миллисекунды
Сборка мусора        | Продолжительность % от общего времени выполнения
Попадания в кэш      | Количество попаданий в секунду

Это весьма общие характеристики и они характерны большенству приложений, будь то веб сервер или почтовый клиент.

--

Где же найти место вопросам производительности в процессе разработки ПО?

Во-прервых, как я говорил раньше. На этапе проектирования приложения необходимо выяснить какие характеристики производительности хотелось бы отслеживать, какие значения этих характеристик хотелось бы получить и при каких условиях планируется эксплуатация разрабатываемого приложения.

На этапе разработки желательно как можно чаще производить замеры интересующих характеристик на прототипах, а так же выполнять нагрузочное тестирование, для того, чтобы отслеживать процесс деградации производительности.

Перед каждым релизом обязательно производить полное нагрузочное тестирование.

Стоит отметить, что создание комплекса нагрузочных тестов, изолированного окружения и тщательный анализ результатов отнимает достаточно много времени, однако взамен вы получаете гарантию того, что снижение производительности не пройдет незамечанным.

--

Построение догадок и преждевременных выводов об узких местах в приложении - это самое худшее, что может сделать разработчик. 

Однажды, когда я активно вел разработку над мобильным android приложением вместе с Димой Николенко, появилась проблема со стандартными библиотечными методами работы с http запросами. Если не ошибаюсь класс называется UrlConnection. У него какая-то жесть была с поддержкой многопоточных запросов на сервер. Решили найти альтернативу, на глаза попался Apache HttpClient с его ThreadSafeClientConnManager, ну я значит решил все, если есть сочетание Thread Safe значит все впорядке. А что оказалось в итоге, этот ThreadSafeClientConnManager плодил кучу ненужных потоков для каждого соединения из-за чего соответственно приложение втормаживать стало.

В конце концов, нашли мы нормальную замену всему этому добру OkHttp называется, от команды Square. На этот раз проверили его работу профилировщиком, поставляемым Android Studio и благополучно пошли спать.

--

По поводу счетчиков производительности насамом деле можно сказать одно, их просто жуть как много, причем безо всяких проблем программист может написать свой счетчик производительности.

--

